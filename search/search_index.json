{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inleiding","text":"<p>We hebben aangepaste peilen in het Hydromedah model op basis van de nieuwe HDSR peilenkaart. De nieuwe waterlooppeilen  tov het originele Hydromedah model alsook de effecten op de grondwaterstand zijn in \"Resultaat\" beschreven.  Hierna volgt een beschrijving van de resultaten wanneer de deklaag weerstand van het Hydromedah model wordt vervangen  door LHM deklaagweerstand. Het Python notebook waarin u kun de stapsgewijs de aanpassing van het Hydromedah model kunt volgen, vindt u in de paragraaf:  \"Python-notebook\"</p>"},{"location":"resultaat_hydromedah/","title":"Resultaten Hydromedah model","text":""},{"location":"resultaat_hydromedah/#resultaat-aangepaste-peilgebieden","title":"Resultaat aangepaste peilgebieden","text":"<p>De peilgebieden zijn aangepast zoals beschreven in het Python notebook.  In figuur 1 en 2 worden de verschilkaarten weergegeven, waarbij respectievelijk het nieuwe winterpeil minus het Hydromedah winterpeil en het nieuwe zomerpeil minus het Hydromedah zomerpeil worden getoond. Uit deze figuren blijkt dat de peilen over het algemeen zijn verlaagd.</p> <p>In figuur 1 en 2 zie je verschilkaarten tussen respectievelijk het nieuwe winterpeil minus het Hydromedah winterpeil en het nieuwe zomerpeil minus het Hydromedah zomerpeil. Uit deze figuren blijkt dat de peilen over het algemeen verlaagd zijn.   Figuur 1: Verschil nieuw winterpeil minus Hydromedah winterpeil [m]   Figuur 2: Verschil nieuw zomerpeil minus Hydromedah zomerpeil [m]</p>"},{"location":"resultaat_hydromedah/#resultaat-aangepaste-deklaagweerstand","title":"Resultaat aangepaste deklaagweerstand","text":"<p>Zoals te zien is in de figuur zijn de weerstanden in het LHM in veel gebieden veel hoger dan de weerstand in het LHM. </p> <p> Figuur 3: Weerstand deklaag [dag] in Hydromedah (bovenste figuur) en LHM (onderste figuur)</p>"},{"location":"resultaat_hydromedah/#resultaat-gxgs","title":"Resultaat GXG's","text":"<p>In deze paragraaf vindt u de resultaten van de GLG, GHG en GVG van: - Hydromedah model run gedraaid in 2021 (figuur 4) - Hydromedah model run gedraaid in 2023 (figuur 5) - aangepaste Hydromedah model gedraaid in 2023 (nieuwe peilgebieden kaart en deklaagweerstand overgenomen uit LHM) (figuur 6)</p> <p>Zoals te zien is in de figuren zijn de GXG's van 2021 en 2023 niet gelijk. We moeten de oorzaak hiervan nog achterhalen. </p> <p> Figuur 4: GXG kaarten van het Hydromedah model (2021)</p> <p> Figuur 5: GXG kaarten van het Hydromedah model (2023)</p> <p> Figuur 6: GXG kaarten van het aangepaste Hydromedah model(2023):nieuwe peilgebieden kaart en deklaagweerstand overgenomen uit LHM</p>"},{"location":"resultaat_hydromedah/#resultaat-grondwatertrappen","title":"Resultaat grondwatertrappen","text":"<p>Hierbij de resultaatfiguren van de grondwatertrappen van: - Hydromedah model run gedraaid in 2021 (figuur 7) - Hydromedah model run gedraaid in 2023 (figuur 8) - aangepaste Hydromedah model gedraaid in 2023 (nieuwe peilgebieden kaart en deklaagweerstand overgenomen uit LHM) (figuur 9)</p> <p>Zoals te zien is in de figuren zijn de Grondwatertrappen van 2021 en 2023 niet gelijk. We moeten de oorzaak hiervan nog achterhalen. </p> <p> Figuur 7: Grondwatertrappen kaart van het Hydromedah model (2021)</p> <p> Figuur 8: Grondwatertrappen kaart van Hydromedah model (2023)</p> <p> Figuur 9: Grondwatertrappen kaart van het aangepaste Hydromedah model (2023):nieuwe peilgebieden kaart en deklaagweerstand overgenomen uit LHM</p>"},{"location":"updaten_hydromedah/","title":"Python notebook","text":"In\u00a0[1]: Copied! <pre>try: # to bypass ImportError at rasterio.__init__ from rasterio.__version ....\n    import rasterio\nexcept ImportError:\n    from osgeo import gdal\n    import rasterio\n\nfrom dask import array # If you don't do this imod.idf.open() (version 0.9.0) will give an AttributeError: module 'dask' has no attribute 'array'\nimport geopandas as gpd\nimport imod\nimport numpy as np\nfrom pathlib import Path\nimport shutil\nfrom rasterio.features import rasterize\nfrom rasterio.fill import fillnodata\nimport xarray as xr\n\nfrom nhi_data import Ondergrond\n\nimport warnings\nwarnings.filterwarnings(\"ignore\") # To avoid logging RuntimeWarning in rasterio.fill.fillnodata\n</pre> try: # to bypass ImportError at rasterio.__init__ from rasterio.__version ....     import rasterio except ImportError:     from osgeo import gdal     import rasterio  from dask import array # If you don't do this imod.idf.open() (version 0.9.0) will give an AttributeError: module 'dask' has no attribute 'array' import geopandas as gpd import imod import numpy as np from pathlib import Path import shutil from rasterio.features import rasterize from rasterio.fill import fillnodata import xarray as xr  from nhi_data import Ondergrond  import warnings warnings.filterwarnings(\"ignore\") # To avoid logging RuntimeWarning in rasterio.fill.fillnodata In\u00a0[2]: Copied! <pre>oppervlaktewater_dir = Path(r\"d:\\projecten\\D2304.HDSR_TEO_debieten\\02.model\\data\\hydromedah\\oppervlaktewater\")\n\ntemplate_idf = oppervlaktewater_dir.joinpath(\"winter\", \"PEIL_LAAG1_1.IDF\")\ntemplate_da = imod.idf.open(template_idf)\n\nshape = template_da.shape\nheight, width = template_da.shape\ntransform = imod.util.transform(template_da)\n\n_, xmin, xmax, _, ymin, ymax = imod.util.spatial_reference(template_da)\n</pre> oppervlaktewater_dir = Path(r\"d:\\projecten\\D2304.HDSR_TEO_debieten\\02.model\\data\\hydromedah\\oppervlaktewater\")  template_idf = oppervlaktewater_dir.joinpath(\"winter\", \"PEIL_LAAG1_1.IDF\") template_da = imod.idf.open(template_idf)  shape = template_da.shape height, width = template_da.shape transform = imod.util.transform(template_da)  _, xmin, xmax, _, ymin, ymax = imod.util.spatial_reference(template_da) In\u00a0[3]: Copied! <pre>ondergrond = Ondergrond(bbox=(xmin,ymin,xmax,ymax))\nlayer = ondergrond.get_layers(filter=\"resistance_layer1\")[0]\nprint(layer)\n</pre> ondergrond = Ondergrond(bbox=(xmin,ymin,xmax,ymax)) layer = ondergrond.get_layers(filter=\"resistance_layer1\")[0] print(layer) <pre>ondergrond2:vertical_resistance_layer1_lhm41\n</pre> In\u00a0[4]: Copied! <pre>ondergrond.download_layer(layer, \"vertical_resistance_layer1.tif\")\nondergrond.download_layer(layer, \"vertical_resistance_layer1.idf\")\n</pre> ondergrond.download_layer(layer, \"vertical_resistance_layer1.tif\") ondergrond.download_layer(layer, \"vertical_resistance_layer1.idf\") In\u00a0[5]: Copied! <pre>peilengebieden_gdf = gpd.read_file(\"Peilgebieden.geojson\", engine=\"pyogrio\")\npeilengebieden_gdf.explore()\n</pre> peilengebieden_gdf = gpd.read_file(\"Peilgebieden.geojson\", engine=\"pyogrio\") peilengebieden_gdf.explore() Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[6]: Copied! <pre>peilen_gdf = gpd.GeoDataFrame(peilengebieden_gdf[\"geometry\"])\npeilen_gdf.to_crs(28992, inplace=True)\npeilen_gdf[\"soort_streefpeil\"] = peilengebieden_gdf[\"SOORTSTREEFPEIL\"]\npeilen_gdf[\"code\"] = peilengebieden_gdf[\"CODE\"]\npeilen_gdf[\"nodata\"] = False\n</pre> peilen_gdf = gpd.GeoDataFrame(peilengebieden_gdf[\"geometry\"]) peilen_gdf.to_crs(28992, inplace=True) peilen_gdf[\"soort_streefpeil\"] = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] peilen_gdf[\"code\"] = peilengebieden_gdf[\"CODE\"] peilen_gdf[\"nodata\"] = False In\u00a0[7]: Copied! <pre>peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 1\n\n# VASTPEIL = -999 komt voor, dit maskeren we en leggen we vast als no data\ndata_mask = (peilengebieden_gdf[\"VASTPEIL\"] != -999) &amp; ~peilengebieden_gdf[\"VASTPEIL\"].isna()\npeilen_gdf.loc[(peil_mask &amp;  ~data_mask), [\"nodata\"]] = True\n\n# vullen zomerpeil en winterpeil\npeilen_gdf.loc[(peil_mask &amp; data_mask), [\"zomerpeil\"]] = peilengebieden_gdf[(peil_mask &amp; data_mask)][\"VASTPEIL\"]\npeilen_gdf.loc[(peil_mask &amp; data_mask), [\"winterpeil\"]] = peilengebieden_gdf[(peil_mask &amp; data_mask)][\"VASTPEIL\"]\n</pre> peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 1  # VASTPEIL = -999 komt voor, dit maskeren we en leggen we vast als no data data_mask = (peilengebieden_gdf[\"VASTPEIL\"] != -999) &amp; ~peilengebieden_gdf[\"VASTPEIL\"].isna() peilen_gdf.loc[(peil_mask &amp;  ~data_mask), [\"nodata\"]] = True  # vullen zomerpeil en winterpeil peilen_gdf.loc[(peil_mask &amp; data_mask), [\"zomerpeil\"]] = peilengebieden_gdf[(peil_mask &amp; data_mask)][\"VASTPEIL\"] peilen_gdf.loc[(peil_mask &amp; data_mask), [\"winterpeil\"]] = peilengebieden_gdf[(peil_mask &amp; data_mask)][\"VASTPEIL\"] In\u00a0[8]: Copied! <pre>peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 2\n\n# bij -999 in bovenpeil stellen we bovenpeil gelijk aan onderpeil\nnodata_mask = peil_mask &amp; (peilengebieden_gdf[\"BOVENPEIL\"] == -999)\npeilengebieden_gdf.loc[nodata_mask, [\"BOVENPEIL\"]] = peilengebieden_gdf[nodata_mask][\"ONDERPEIL\"]\n\n# bij -999 in onderpeil stellen we onderpeil gelijk aan bovenpeil\nnodata_mask = peil_mask &amp; (peilengebieden_gdf[\"ONDERPEIL\"] == -999)\npeilengebieden_gdf.loc[nodata_mask, [\"ONDERPEIL\"]] = peilengebieden_gdf[nodata_mask][\"BOVENPEIL\"]\n\npeilen_gdf.loc[peil_mask, [\"zomerpeil\"]] = (peilengebieden_gdf[peil_mask][\"ONDERPEIL\"] + peilengebieden_gdf[peil_mask][\"BOVENPEIL\"]) / 2\npeilen_gdf.loc[peil_mask, [\"winterpeil\"]] = peilen_gdf[peil_mask][\"zomerpeil\"]\n</pre> peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 2  # bij -999 in bovenpeil stellen we bovenpeil gelijk aan onderpeil nodata_mask = peil_mask &amp; (peilengebieden_gdf[\"BOVENPEIL\"] == -999) peilengebieden_gdf.loc[nodata_mask, [\"BOVENPEIL\"]] = peilengebieden_gdf[nodata_mask][\"ONDERPEIL\"]  # bij -999 in onderpeil stellen we onderpeil gelijk aan bovenpeil nodata_mask = peil_mask &amp; (peilengebieden_gdf[\"ONDERPEIL\"] == -999) peilengebieden_gdf.loc[nodata_mask, [\"ONDERPEIL\"]] = peilengebieden_gdf[nodata_mask][\"BOVENPEIL\"]  peilen_gdf.loc[peil_mask, [\"zomerpeil\"]] = (peilengebieden_gdf[peil_mask][\"ONDERPEIL\"] + peilengebieden_gdf[peil_mask][\"BOVENPEIL\"]) / 2 peilen_gdf.loc[peil_mask, [\"winterpeil\"]] = peilen_gdf[peil_mask][\"zomerpeil\"] In\u00a0[9]: Copied! <pre>peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 3\n\npeilen_gdf.loc[peil_mask, [\"zomerpeil\"]] = peilengebieden_gdf[peil_mask][\"ZOMERPEIL\"]\npeilen_gdf.loc[peil_mask, [\"winterpeil\"]] = peilengebieden_gdf[peil_mask][\"WINTERPEIL\"]\n</pre> peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 3  peilen_gdf.loc[peil_mask, [\"zomerpeil\"]] = peilengebieden_gdf[peil_mask][\"ZOMERPEIL\"] peilen_gdf.loc[peil_mask, [\"winterpeil\"]] = peilengebieden_gdf[peil_mask][\"WINTERPEIL\"] In\u00a0[10]: Copied! <pre>peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] &gt;= 4\npeilen_gdf.loc[peil_mask, [\"nodata\"]] = True\n</pre> peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] &gt;= 4 peilen_gdf.loc[peil_mask, [\"nodata\"]] = True In\u00a0[11]: Copied! <pre>data_mask = ~peilen_gdf[\"nodata\"]\npeilen_gdf.loc[data_mask, [\"peil_betrouwbaar\"]] =  peilen_gdf[data_mask][\"winterpeil\"] &lt;= peilen_gdf[data_mask][\"zomerpeil\"]\n</pre> data_mask = ~peilen_gdf[\"nodata\"] peilen_gdf.loc[data_mask, [\"peil_betrouwbaar\"]] =  peilen_gdf[data_mask][\"winterpeil\"] &lt;= peilen_gdf[data_mask][\"zomerpeil\"] In\u00a0[12]: Copied! <pre>peilen_gdf.to_file(\"peilen.gpkg\")\n</pre> peilen_gdf.to_file(\"peilen.gpkg\") In\u00a0[13]: Copied! <pre>crs = peilen_gdf.crs\n\nprofile={ # profiel voor GeoTifs\n    \"driver\": \"GTiff\",\n    \"dtype\":rasterio.dtypes.float32,\n    \"nodata\": -999,\n    \"width\" :width,\n    \"height\": height,\n    \"count\": 1,\n    \"crs\": crs,\n    \"transform\": transform}\n</pre> crs = peilen_gdf.crs  profile={ # profiel voor GeoTifs     \"driver\": \"GTiff\",     \"dtype\":rasterio.dtypes.float32,     \"nodata\": -999,     \"width\" :width,     \"height\": height,     \"count\": 1,     \"crs\": crs,     \"transform\": transform} In\u00a0[14]: Copied! <pre>shapes = (\n    (geom, 1)\n    for geom in peilen_gdf[~peilen_gdf[\"code\"].isin([\"PG2179\", \"PG2112\"])][\"geometry\"]\n    )\n\nmask_array = rasterize(\n    shapes=shapes,\n    out_shape=shape,\n    transform=transform,\n    all_touched=True)\n\nwith rasterio.open(\"mask.tif\", \"w+\", **profile) as dst:\n    dst.write(mask_array, 1)\n</pre> shapes = (     (geom, 1)     for geom in peilen_gdf[~peilen_gdf[\"code\"].isin([\"PG2179\", \"PG2112\"])][\"geometry\"]     )  mask_array = rasterize(     shapes=shapes,     out_shape=shape,     transform=transform,     all_touched=True)  with rasterio.open(\"mask.tif\", \"w+\", **profile) as dst:     dst.write(mask_array, 1) In\u00a0[15]: Copied! <pre>for seizoen in [\"zomer\", \"winter\"]:\n    # 1. Verrasteren van de zomer en winterpeilen waar deze data bevatten. We schrijven deze weg in `zomerpeil_origineel.tif` en `winterpeil_origineel.tif`\n    shapes = (\n        (geom, value)\n        for geom, value in zip(peilen_gdf[~peilen_gdf.nodata][\"geometry\"], peilen_gdf[~peilen_gdf.nodata][f\"{seizoen}peil\"])\n        )\n    \n    peil_array = rasterize(\n        shapes=shapes,\n        out_shape=shape,\n        fill=-999,\n        transform=transform,\n        all_touched=False)\n    \n    with rasterio.open(f\"{seizoen}peil_ruw.tif\", \"w+\", **profile) as dst:\n        dst.write(peil_array, 1)\n\n    # 2. Het opvullen van `nodata` cellen binnen het mask door middel van interpolatie. We schrijven deze weg als `zomerpeil.tif` en `winterpeil.tif\n    mask = np.where((peil_array == -999) &amp; (mask_array == 1), 0, 1)\n    mask = np.where(mask_array == 0, np.NaN, mask)\n    peil_array = fillnodata(\n        peil_array,\n        mask=mask,\n        max_search_distance=20,\n        smoothing_iterations=0\n        )\n    \n    peil_array = np.where(mask_array == 1, peil_array, -999)\n    with rasterio.open(f\"{seizoen}peil.tif\", \"w+\", **profile) as dst:\n        dst.write(peil_array, 1)\n    \n    dataset = imod.rasterio.open(f\"{seizoen}peil.tif\")\n    imod.idf.save(f\"{seizoen}peil\", dataset)\n\n    # 3. Het overschrijven van de waarden in alle `PEIL_LAAG*.IDF` bestanden\n    out_dir = Path(seizoen)\n    if out_dir.exists():\n        shutil.rmtree(out_dir)\n    out_dir.mkdir()\n    datasets = imod.idf.open_dataset(oppervlaktewater_dir.joinpath(seizoen,\"PEIL_LAAG*.IDF\"))\n    \n    for laag, peil_da in datasets.items():\n\n        # - `nodata` in de oorspronkelijke peilen blijft `nodata`in de nieuwe peilen\n        peil_da = xr.where(\n            np.isnan(peil_da),\n            peil_da,\n            np.where(peil_array == -999, peil_da, peil_array)\n            )\n        \n        # - Wanneer er een er een bodemhoogte is wordt het nieuwe peil gelijk of hoger dan de bodemhoogte\n        bodemhoogte_name = f\"BODEMHOOGTE_LAAG{laag[len(laag)-3:]}\"\n        bodemhoogte_da = imod.idf.open(\n            oppervlaktewater_dir.joinpath(seizoen,f\"{bodemhoogte_name}.IDF\")\n            )\n        peil_da = xr.where(\n            np.isnan(peil_da),\n            peil_da,\n            xr.where(\n                np.isnan(bodemhoogte_da),\n                peil_da,\n                xr.where(\n                    bodemhoogte_da &lt; peil_da,\n                    peil_da,\n                    bodemhoogte_da\n                    ) # zowel bodemhoogte als peil zijn niet NaN\n                )\n            )\n        # Wegschrijven IDF\n        imod.idf.write(out_dir / f\"{laag}.idf\", peil_da)\n</pre> for seizoen in [\"zomer\", \"winter\"]:     # 1. Verrasteren van de zomer en winterpeilen waar deze data bevatten. We schrijven deze weg in `zomerpeil_origineel.tif` en `winterpeil_origineel.tif`     shapes = (         (geom, value)         for geom, value in zip(peilen_gdf[~peilen_gdf.nodata][\"geometry\"], peilen_gdf[~peilen_gdf.nodata][f\"{seizoen}peil\"])         )          peil_array = rasterize(         shapes=shapes,         out_shape=shape,         fill=-999,         transform=transform,         all_touched=False)          with rasterio.open(f\"{seizoen}peil_ruw.tif\", \"w+\", **profile) as dst:         dst.write(peil_array, 1)      # 2. Het opvullen van `nodata` cellen binnen het mask door middel van interpolatie. We schrijven deze weg als `zomerpeil.tif` en `winterpeil.tif     mask = np.where((peil_array == -999) &amp; (mask_array == 1), 0, 1)     mask = np.where(mask_array == 0, np.NaN, mask)     peil_array = fillnodata(         peil_array,         mask=mask,         max_search_distance=20,         smoothing_iterations=0         )          peil_array = np.where(mask_array == 1, peil_array, -999)     with rasterio.open(f\"{seizoen}peil.tif\", \"w+\", **profile) as dst:         dst.write(peil_array, 1)          dataset = imod.rasterio.open(f\"{seizoen}peil.tif\")     imod.idf.save(f\"{seizoen}peil\", dataset)      # 3. Het overschrijven van de waarden in alle `PEIL_LAAG*.IDF` bestanden     out_dir = Path(seizoen)     if out_dir.exists():         shutil.rmtree(out_dir)     out_dir.mkdir()     datasets = imod.idf.open_dataset(oppervlaktewater_dir.joinpath(seizoen,\"PEIL_LAAG*.IDF\"))          for laag, peil_da in datasets.items():          # - `nodata` in de oorspronkelijke peilen blijft `nodata`in de nieuwe peilen         peil_da = xr.where(             np.isnan(peil_da),             peil_da,             np.where(peil_array == -999, peil_da, peil_array)             )                  # - Wanneer er een er een bodemhoogte is wordt het nieuwe peil gelijk of hoger dan de bodemhoogte         bodemhoogte_name = f\"BODEMHOOGTE_LAAG{laag[len(laag)-3:]}\"         bodemhoogte_da = imod.idf.open(             oppervlaktewater_dir.joinpath(seizoen,f\"{bodemhoogte_name}.IDF\")             )         peil_da = xr.where(             np.isnan(peil_da),             peil_da,             xr.where(                 np.isnan(bodemhoogte_da),                 peil_da,                 xr.where(                     bodemhoogte_da &lt; peil_da,                     peil_da,                     bodemhoogte_da                     ) # zowel bodemhoogte als peil zijn niet NaN                 )             )         # Wegschrijven IDF         imod.idf.write(out_dir / f\"{laag}.idf\", peil_da)"},{"location":"updaten_hydromedah/#python-notebook","title":"Python notebook\u00b6","text":"<p>Met deze Notebook genereren we de volgende output:</p> <ul> <li><code>vertical_resistance_layer1</code>: een nieuwe verticale weerstand voor de deklaag</li> <li><code>winter\\peil_laag#_#.idf</code>: nieuwe peilen voor de winter in de verschillende (sub) lagen</li> <li><code>zomer\\peil_laag#_#.idf</code>: nieuwe peilen voor de zomer in de verschillende (sub) lagen</li> </ul> <p>Een aantal relevante tussenproducten:</p> <ul> <li><code>peilen.gpkg</code>: de geaggregeerde vaste/zomer/winter en flexibele peilen naar 1 zomer en 1 winterpeil, wanneer deze kan worden berekend</li> <li><code>winterpeil_ruw.tif</code>, <code>winterpeil.tif</code>, <code>winterpeil.idf</code>: het ruwe en geinterpoleerde resultaat van de verrastering van de kolom <code>winterpeil</code> in <code>peilen.gpkg</code></li> <li><code>zomerpeil_ruw.tif</code>, <code>zomerpeil.tif</code>, <code>zomerpeil.idf</code>: het ruwe en geinterpoleerde resultaat van de verrastering van de kolom <code>zomerpeil</code> in <code>peilen.gpkg</code></li> </ul> <p>In deze Notebook worden alle tussen en eindproducten stap-voor-stap gegenereerd met duiding en Python-code.</p>"},{"location":"updaten_hydromedah/#specificaties-imodflow-inlezen","title":"Specificaties iMODFLOW inlezen\u00b6","text":"<p>We lezen de specificatie van het iMODFLOW model in. We gebruiken daarvoor de laag <code>PEIL_LAAG1_1.IDF</code>, waarvan we de ruimtelijke attributen overnemen.</p>"},{"location":"updaten_hydromedah/#vervangen-deklaagweerstand","title":"Vervangen deklaagweerstand\u00b6","text":"<p>Hier vervangen we de verticale weerstand van de deklaag uit het LHM4.1</p>"},{"location":"updaten_hydromedah/#inladen-nhi-ondergrond","title":"Inladen NHI ondergrond\u00b6","text":"<p>We maken een Ondergrond-object, voor de bounding-box van het HDSR MODFLOW model. We zoeken de juiste laag op de NHI-geoserver</p>"},{"location":"updaten_hydromedah/#download-en-conversie-naar-geotiff-en-idf","title":"Download en conversie naar GeoTIFF en IDF\u00b6","text":"<p>Met dit object kunnen we de laag downloaden en opslaan als GeoTiff en IDF</p>"},{"location":"updaten_hydromedah/#vervangen-peil-en-peilgebieden","title":"Vervangen peil en peilgebieden\u00b6","text":"<p>Hier vervangen we de oppervlaktewaterpeilen van het iMODFLOW model</p>"},{"location":"updaten_hydromedah/#inladen-peilgebieden","title":"Inladen peilgebieden\u00b6","text":"<p>De peilgebieden zijn op 04-07-2023 gedownload (gegenereerd op 23 jun 2023 11:04) via de HDSR Infovijver als GeoJSON.</p>"},{"location":"updaten_hydromedah/#aggregeren-peilen-naar-zomer-en-winterpeil","title":"Aggregeren peilen naar zomer- en winterpeil\u00b6","text":"<p>We lezen de geometrieen in van de peilgebieden en kopieren het attribuut <code>SOORTSTREEFPEIL</code> (<code>soort_streefpeil</code>) met de volgende enumeratie:</p> <ul> <li><code>1</code>: vast peil</li> <li><code>2</code>: flexibel peil</li> <li><code>3</code>: zomer- en winterpeil</li> <li><code>4</code>, <code>5</code>, <code>99</code>: geen peil vastgesteld/peil onbekend</li> </ul> <p>We willen de volgende kolommen vullen:</p> <ul> <li><code>code</code>: waterschapscode</li> <li><code>nodata</code>: geen zomer- winterpeil bekend = <code>True</code>, anders <code>False</code></li> <li><code>betrouwbaar_peil</code>: <code>winterpeil</code> &lt;= <code>zomerpeil</code> = <code>True</code>, anders <code>False</code></li> <li><code>zomerpeil</code></li> <li><code>winterpeil</code></li> </ul> <p>We projecteren de geometri\u00ebn naar Rijksdriehoekstelsel (epsg 28992) en vullen de kolommen <code>soort_streefpeil</code>, <code>code</code> uit de oorspronkelijke data en zetten de waarden van de kolom <code>nodata</code> op <code>False</code>.</p>"},{"location":"updaten_hydromedah/#vast-peil","title":"Vast Peil\u00b6","text":"<p>Wanneer <code>VASTPEIL</code> == -999 of niet ingevuld, dan geven we dit aan in <code>nodata</code>. Voor de peilgebieden waarvan gegevens bekend zijn geldt <code>zomerpeil</code> = <code>winterpeil</code> = <code>vastpeil</code></p>"},{"location":"updaten_hydromedah/#flexibel-peil","title":"Flexibel peil\u00b6","text":"<p>In zowel <code>ONDERPEIL</code> als <code>BOVENPEIL</code> komt -999 voor, maar niet gelijktijdig. In deze gevallen stellen we <code>ONDERPEIL</code> gelijk aan <code>BOVENPEIL</code> of vise-versa. Vervolgens brekenen we <code>zomerpeil</code> en <code>winterpeil</code>:</p> <pre><code>zomerpeil = winterpeil = (ONDERPEIL + BOVENPEIL) / 2\n</code></pre>"},{"location":"updaten_hydromedah/#zomer-en-winterpeil","title":"Zomer- en winterpeil\u00b6","text":"<p>Hier komen geen ontbrekende, danwel -999 waarden voor, dus deze nemen we direct over</p>"},{"location":"updaten_hydromedah/#onbrekende-peilen","title":"Onbrekende peilen\u00b6","text":"<p>Wanneer peilen ontbreken, geven we dat aan door <code>nodata</code> op <code>True</code> te zetten</p>"},{"location":"updaten_hydromedah/#indicatie-betrouwbaarheid","title":"Indicatie betrouwbaarheid\u00b6","text":"<p>Voor alle gebieden met <code>zomerpeil</code> en <code>winterpeil</code> controleren we of <code>winterpeil</code> kleiner of gelijk aan <code>zomerpeil</code> is.</p>"},{"location":"updaten_hydromedah/#wegschrijven","title":"Wegschrijven\u00b6","text":""},{"location":"updaten_hydromedah/#conversie-naar-imod","title":"Conversie naar imod\u00b6","text":"<p>Het resultaat in <code>peilen_gdf</code> wordt weggeschreven naar idf-bestanden. Van de verrasterde peilen schrijven we tevens GeoTifs weg, zodat deze in GIS kunnen worden geladen.</p>"},{"location":"updaten_hydromedah/#data-mask","title":"Data mask\u00b6","text":"<p>We zorgen dat de Utrechtse Heuvelrug (<code>PG2179</code>) en Nederrijn en Lek (<code>PG2112</code>) uit de peilen-rasters blijven. We houden daar de oorspronkelijke waarden. Het deel waar we peilen voor verrasteren schrijven we weg als <code>mask.tif</code>.</p>"},{"location":"updaten_hydromedah/#verwerking-in-idfs","title":"Verwerking in IDFs\u00b6","text":"<p>Voor de seizoenen <code>zomer</code> en <code>winter</code> voeren we de volgende stappen uit:</p> <ol> <li>Verrasteren van de zomer en winterpeilen waar deze data bevatten. We schrijven deze weg in <code>zomerpeil_ruw.tif</code> en <code>winterpeil_ruw.tif</code></li> <li>Het opvullen van <code>nodata</code> cellen binnen het mask door middel van interpolatie. We schrijven deze weg als <code>zomerpeil.tif</code> en <code>winterpeil.tif</code></li> <li>Het overschrijven van de waarden in alle <code>PEIL_LAAG*.IDF</code> bestanden uit het oorsprokelijke model met de regels:<ul> <li><code>nodata</code> in de oorspronkelijke peilen blijft <code>nodata</code>in de nieuwe peilen</li> <li>Wanneer er een er een bodemhoogte is wordt het nieuwe peil gelijk of hoger dan de bodemhoogte</li> </ul> </li> </ol>"},{"location":"vergelijking_laterals/","title":"Vergelijking lateralen","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n\n# De locatie waar de informatieproducten worden geplaastst.\nexport_path = Path('../results')\n</pre> from pathlib import Path import pandas as pd import matplotlib.pyplot as plt  %matplotlib inline  # De locatie waar de informatieproducten worden geplaastst. export_path = Path('../results') In\u00a0[2]: Copied! <pre># inlezen csv met het origineel uit 2021\ndf_origineel = pd.read_csv(\n    export_path.joinpath(r\"geleverd_Ruud\\Maatgevend\\laterale_flux\\Laterals_Huidig250.csv\"),\n    index_col=0,\n)\ndf_origineel.index = pd.to_datetime(df_origineel.index) # Index naar datetime\ndf_origineel.drop(labels=[\"0\"], axis=1, inplace=True) # de eerste kolom is leeg, dus gooien we weg\n\n# inlezen csv met nieuwe run en hetzelde model\ndf_huidig = pd.read_csv(\n    export_path.joinpath(r\"Maatgevend\\laterals_Huidig250.csv\"),\n    index_col=0,\n)\ndf_huidig.index = pd.to_datetime(df_huidig.index) # Index naar datetime\ndf_huidig.drop(labels=['0'], axis=1, inplace=True) # de eerste kolom is leeg, dus gooien we weg\n</pre> # inlezen csv met het origineel uit 2021 df_origineel = pd.read_csv(     export_path.joinpath(r\"geleverd_Ruud\\Maatgevend\\laterale_flux\\Laterals_Huidig250.csv\"),     index_col=0, ) df_origineel.index = pd.to_datetime(df_origineel.index) # Index naar datetime df_origineel.drop(labels=[\"0\"], axis=1, inplace=True) # de eerste kolom is leeg, dus gooien we weg  # inlezen csv met nieuwe run en hetzelde model df_huidig = pd.read_csv(     export_path.joinpath(r\"Maatgevend\\laterals_Huidig250.csv\"),     index_col=0, ) df_huidig.index = pd.to_datetime(df_huidig.index) # Index naar datetime df_huidig.drop(labels=['0'], axis=1, inplace=True) # de eerste kolom is leeg, dus gooien we weg In\u00a0[3]: Copied! <pre>df_origineel[\"1727\"].plot()\n</pre> df_origineel[\"1727\"].plot() Out[3]: <pre>&lt;AxesSubplot:&gt;</pre> In\u00a0[4]: Copied! <pre>df_origineel.drop(labels=[\"1727\"], axis=1, inplace=True)\ndf_huidig.drop(labels=[\"1727\"], axis=1, inplace=True)\n</pre> df_origineel.drop(labels=[\"1727\"], axis=1, inplace=True) df_huidig.drop(labels=[\"1727\"], axis=1, inplace=True) In\u00a0[5]: Copied! <pre>series_origineel = df_origineel.sum(axis=1)\nseries_huidig = df_huidig.sum(axis=1)\n</pre> series_origineel = df_origineel.sum(axis=1) series_huidig = df_huidig.sum(axis=1) In\u00a0[6]: Copied! <pre>def grafiek(series_origineel, series_huidig, y_label, figsize=(12, 6)):\n    \n    \n    years = pd.date_range(start=\"2010-07-01\", end=\"2021-07-01\", freq=\"AS-JUL\")\n    plt.figure(figsize=figsize) #setten van de grootte van de figuur\n\n    # Plotten van de data\n    plt.plot(series_origineel, label=\"origineel\")\n    plt.plot(series_huidig, label=\"huidig\")\n\n    # Grafiek opmaken\n    plt.xlabel(\"Tijd\")\n    plt.ylabel(y_label)\n    plt.legend()\n    plt.grid(True)\n    plt.xlim(\"2010-07-01\", \"2021-06-30\")\n    plt.xticks(years, years.strftime('%Y-%m-%d'), rotation=90)\n    \n    # Tonen\n    plt.show()\n</pre> def grafiek(series_origineel, series_huidig, y_label, figsize=(12, 6)):               years = pd.date_range(start=\"2010-07-01\", end=\"2021-07-01\", freq=\"AS-JUL\")     plt.figure(figsize=figsize) #setten van de grootte van de figuur      # Plotten van de data     plt.plot(series_origineel, label=\"origineel\")     plt.plot(series_huidig, label=\"huidig\")      # Grafiek opmaken     plt.xlabel(\"Tijd\")     plt.ylabel(y_label)     plt.legend()     plt.grid(True)     plt.xlim(\"2010-07-01\", \"2021-06-30\")     plt.xticks(years, years.strftime('%Y-%m-%d'), rotation=90)          # Tonen     plt.show() In\u00a0[7]: Copied! <pre>grafiek(\n    series_origineel, series_huidig,\n    \"Debiet naar watersysteem [m3/s]\"\n)\n</pre> grafiek(     series_origineel, series_huidig,     \"Debiet naar watersysteem [m3/s]\" ) In\u00a0[8]: Copied! <pre>hdsr_area_m2 = 830210666 # berekend uit waterschapsgrenzen shapefile (in rijksdriehoekstelsel)\n\n# van seconden naar (x 86400) dag, van m3 naar m (/ oppervlak HDSR) en van m naar mm (x 1000)\nseries_origineel_mm = ((series_origineel * 86400 * 1000) / hdsr_area_m2).loc['2010-07-01':'2021-06-30']\nseries_huidig_mm = ((series_huidig * 86400 * 1000) / hdsr_area_m2).loc['2010-07-01':'2021-06-30']\n\n# plotten van de grafieken\ngrafiek(\n    series_origineel_mm.loc['2010-07-01':'2021-07-01'].cumsum(),\n    series_huidig_mm.loc['2010-07-01':'2021-07-01'].cumsum(),\n    \"Cumulatief naar watersysteem [mm]\"\n)\n</pre> hdsr_area_m2 = 830210666 # berekend uit waterschapsgrenzen shapefile (in rijksdriehoekstelsel)  # van seconden naar (x 86400) dag, van m3 naar m (/ oppervlak HDSR) en van m naar mm (x 1000) series_origineel_mm = ((series_origineel * 86400 * 1000) / hdsr_area_m2).loc['2010-07-01':'2021-06-30'] series_huidig_mm = ((series_huidig * 86400 * 1000) / hdsr_area_m2).loc['2010-07-01':'2021-06-30']  # plotten van de grafieken grafiek(     series_origineel_mm.loc['2010-07-01':'2021-07-01'].cumsum(),     series_huidig_mm.loc['2010-07-01':'2021-07-01'].cumsum(),     \"Cumulatief naar watersysteem [mm]\" ) In\u00a0[9]: Copied! <pre>def custom_year_grouping(series):\n    year = series.index.year\n    month = series.index.month\n    custom_year = year + (month &gt;= 7)\n    return custom_year\n\ngrafiek(\n    series_origineel_mm.groupby(custom_year_grouping(series_origineel_mm)).apply(lambda x: x.cumsum()),\n    series_huidig_mm.groupby(custom_year_grouping(series_huidig_mm)).apply(lambda x: x.cumsum()),\n    \"Cumulatief per jaar naar watersysteem [mm]\"\n)\n</pre> def custom_year_grouping(series):     year = series.index.year     month = series.index.month     custom_year = year + (month &gt;= 7)     return custom_year  grafiek(     series_origineel_mm.groupby(custom_year_grouping(series_origineel_mm)).apply(lambda x: x.cumsum()),     series_huidig_mm.groupby(custom_year_grouping(series_huidig_mm)).apply(lambda x: x.cumsum()),     \"Cumulatief per jaar naar watersysteem [mm]\" )"},{"location":"vergelijking_laterals/#vergelijking-lateralen","title":"Vergelijking lateralen\u00b6","text":"<p>Met deze notebook vergelijken we de lateralen uit de resultaten van het model geleverd in 2021 (<code>origineel</code>) met de resultaten van hetzelfde model in dit project (<code>huidig</code>)</p>"},{"location":"vergelijking_laterals/#1-voorbereiding","title":"1. Voorbereiding\u00b6","text":"<p>We lezen alle modules en paden in</p>"},{"location":"vergelijking_laterals/#2-inlezen","title":"2. Inlezen\u00b6","text":"<p>We lezen de csvs met laterale debieten in</p>"},{"location":"vergelijking_laterals/#21-inlezen","title":"2.1. Inlezen\u00b6","text":"<p>Hieronder lezen we de CSV's in</p>"},{"location":"vergelijking_laterals/#22-filteren-lateral-1727","title":"2.2. Filteren lateral 1727\u00b6","text":"<p>Op de Utrechtse heuvelrug zit een lateraal die 18.25 m3/s onttrekt uit het oppervlaktewatersysteem. In verhouding, op het de hele oppervlakte van HDSR (+/- 83000 ha) ongeveer 2mm/dag (ongeveer 700 mm/jaar).</p>"},{"location":"vergelijking_laterals/#3-sommeren-naar-hdsr","title":"3. Sommeren naar HDSR\u00b6","text":"<p>We sommeren de debieten naar het hele beheergebied van HDSR</p>"},{"location":"vergelijking_laterals/#3-plotten","title":"3. Plotten\u00b6","text":"<p>We maken plotjes om de verschillen inzichtelijk te maken</p>"},{"location":"vergelijking_laterals/#32-tijdseries","title":"3.2 Tijdseries\u00b6","text":"<p>We tonen de gesommeerde tijdreeksen.</p>"},{"location":"vergelijking_laterals/#32-tijdseries-cumulatief-over-tijd","title":"3.2 Tijdseries cumulatief over tijd\u00b6","text":"<p>We transformeren de data naar mm/dag en berekenen de cumulatieve onttrekking uit het watersysteem.</p>"},{"location":"vergelijking_laterals/#32-tijdseries-cumulatief-over-tijd-per-jaar","title":"3.2 Tijdseries cumulatief over tijd, per jaar\u00b6","text":"<p>We transformeren de data naar mm/dag en berekenen de cumulatieve onttrekking uit het watersysteem per jaar, waarbij we starten op 01/07 van elk jaar.</p>"}]}